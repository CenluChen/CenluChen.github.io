<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java正则表达式</title>
      <link href="/2019/12/12/java-zheng-ze-biao-da-shi/"/>
      <url>/2019/12/12/java-zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-正则表达式"><a href="#1-正则表达式" class="headerlink" title="1.正则表达式"></a>1.正则表达式</h1><h2 id="1-1-什么是正则表达式"><a href="#1-1-什么是正则表达式" class="headerlink" title="1.1 什么是正则表达式"></a>1.1 什么是正则表达式</h2><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p><p>正则对文本的分析或修改过程为：首先正则表达式应用的是文本字符串（text/string），它会以定义的模式从左到右匹配文本，每个源字符只匹配一次。</p><h2 id="1-2-示例"><a href="#1-2-示例" class="headerlink" title="1.2 示例"></a>1.2 示例</h2><table><thead><tr><th>正则表达式</th><th>匹配</th></tr></thead><tbody><tr><td>hello world</td><td>精准匹配”hello world”</td></tr><tr><td>hello\s+world</td><td>匹配hello后面跟一个或多个空格，再跟上word</td></tr><tr><td>^\d+(.\d+)?</td><td>^定义模式必须匹配字符串的开始，d+ 匹配一个或多个数字，? 表明小括号内的语句是可选的，. 匹配 “.”，小括号表示分组。例如匹配：”5”、”1.5” 和 “2.21”</td></tr></tbody></table><h2 id="1-3字符串自带的正则匹配"><a href="#1-3字符串自带的正则匹配" class="headerlink" title="1.3字符串自带的正则匹配"></a>1.3字符串自带的正则匹配</h2><table><thead><tr><th>方法</th><th>用法</th></tr></thead><tbody><tr><td>s.matches(“regex”)</td><td>当仅且当正则匹配整个字符串时返回 true</td></tr><tr><td>s.split(“regex”)</td><td>按匹配的正则表达式切片字符串(常用)</td></tr><tr><td>s.replaceFirst(“regex”, “replacement”)</td><td>替换首次匹配的字符串片段</td></tr><tr><td>s.replaceAll(“regex”, “replacement”)</td><td>替换所有匹配的字符</td></tr></tbody></table><h1 id="2-Java正则表达式规则"><a href="#2-Java正则表达式规则" class="headerlink" title="2.Java正则表达式规则"></a>2.Java正则表达式规则</h1><h2 id="2-1常见符号"><a href="#2-1常见符号" class="headerlink" title="2.1常见符号"></a>2.1常见符号</h2><table><thead><tr><th>正则表达式</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>匹配所有单个字符，除了换行符（Linux 中换行是 \n，Windows 中换行是 \r\n）</td></tr><tr><td>\</td><td>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。序列”\\“匹配”\“，”\(“匹配”(“</td></tr><tr><td>^pattern</td><td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配</td></tr><tr><td>pattern$</td><td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配</td></tr><tr><td>[xyz]</td><td>字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”</td></tr><tr><td>[abc][xyz]</td><td>复选集定义，匹配字母 a 或 b 或 c，后面跟着 x或y或z</td></tr><tr><td>[^xyz]</td><td>反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母</td></tr><tr><td>[^a-z]</td><td>反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符</td></tr><tr><td>XZ</td><td>匹配X后直接跟着Z</td></tr><tr><td>X|Z</td><td>匹配X或Z</td></tr></tbody></table><h2 id="2-2-元字符"><a href="#2-2-元字符" class="headerlink" title="2.2 元字符"></a>2.2 元字符</h2><p>元字符是一个预定义的字符</p><table><thead><tr><th>正则表达式</th><th>描述</th></tr></thead><tbody><tr><td>\b</td><td>匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”</td></tr><tr><td>\B</td><td>非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”</td></tr><tr><td>\cx</td><td>匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身</td></tr><tr><td>\d</td><td>数字字符匹配。等效于 [0-9]</td></tr><tr><td>\D</td><td>非数字字符匹配。等效于 [^0-9]</td></tr><tr><td>\f</td><td>换页符匹配。等效于 \x0c 和 \cL</td></tr><tr><td>\n</td><td>换行符匹配。等效于 \x0a 和 \cJ</td></tr><tr><td>\r</td><td>匹配一个回车符。等效于 \x0d 和 \cM</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效</td></tr><tr><td>\S</td><td>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效</td></tr><tr><td>\t</td><td>制表符匹配。与 \x09 和 \cI 等效</td></tr><tr><td>\v</td><td>垂直制表符匹配。与 \x0b 和 \cK 等效</td></tr><tr><td>\w</td><td>匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效</td></tr><tr><td>\W</td><td>与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效</td></tr><tr><td>\xn</td><td>匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码</td></tr><tr><td>\num</td><td>匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符</td></tr><tr><td>\n</td><td>标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码</td></tr><tr><td>\nm</td><td>标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)</td></tr><tr><td>\nml</td><td>当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml</td></tr><tr><td>\un</td><td>匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)</td></tr></tbody></table><h2 id="2-3限定符"><a href="#2-3限定符" class="headerlink" title="2.3限定符"></a>2.3限定符</h2><p>限定符定义了一个元素可以发生的频率。</p><table><thead><tr><th>正则表达式</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</td></tr><tr><td>+</td><td>一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</td></tr><tr><td>?</td><td>零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</td></tr><tr><td>{n}</td><td>n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td></tr><tr><td>{n,}</td><td>n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td></tr><tr><td>{n,m}</td><td>m 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td></tr><tr><td>?</td><td>当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</td></tr><tr><td>(pattern)</td><td>匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。</td></tr><tr><td>(?:pattern)</td><td>匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。</td></tr><tr><td>(?=pattern)</td><td>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr><td>(?!pattern)</td><td>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr></tbody></table><h2 id="2-4-表达模式"><a href="#2-4-表达模式" class="headerlink" title="2.4 表达模式"></a>2.4 表达模式</h2><p>在正则表达式的开头指定模式修饰符</p><table><thead><tr><th>修饰符</th><th>意义</th></tr></thead><tbody><tr><td>(?i)</td><td>忽略大小写</td></tr><tr><td>(?s)</td><td>单行模式,使正则的 . 匹配所有字符，包括换行符</td></tr><tr><td>(?m)</td><td>多行模式,使正则的 ^ 和 $ 匹配字符串中每行的开始和结束</td></tr></tbody></table><h2 id="2-5使用"><a href="#2-5使用" class="headerlink" title="2.5使用"></a>2.5使用</h2><p>java.util.regex包主要包括一下三个类</p><ul><li><p><strong>Pattern类</strong><br>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p></li><li><p><strong>Matcher 类</strong>：<br>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p></li><li><p><strong>PatternSyntaxException</strong>：<br>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p><p>实例</p><pre><code>pakage com.java.regex;import java.util.regex.*;class RegexExample1{    public static void main(String[] args){        String content = "hello world, Java regex";        String pattern = ".*llo.*";        boolean isMatch = Pattern.matches(pattern.content);        System.out.println("正则表达式是否匹配? " + isMatch);    }}</code></pre><h2 id="2-6分组和反向引用"><a href="#2-6分组和反向引用" class="headerlink" title="2.6分组和反向引用"></a>2.6分组和反向引用</h2></li></ul><p>小括号 () 可以达到对正则表达式进行分组的效果。例如，正则表达式 (dog) 创建了单一分组，组里包含”d”，”o”，和”g”。</p><p>捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：</p><ul><li>((A)(B(C)))</li><li>(A)</li><li>(B(C))</li><li>(C)<br>可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。</li></ul><p>还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中</p><p>或者使用$来<strong>反向引用</strong>分组，$1表示第一个分组</p><p>实例</p><pre><code>package com.java.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexMatches{    public static void main( String[] args){      // 按指定模式在字符串查找      String line = "This order was placed for QT3000! OK?";      String pattern = "(\\D*)(\\d+)(.*)";      // 创建 Pattern 对象      Pattern r = Pattern.compile(pattern);      // 现在创建 matcher 对象      Matcher m = r.matcher(line);      int n = m.groupCount();      if (m.find( )) {      for(int i = 0;i&lt;=n;i++){         System.out.println("Found value: " + m.group(i) );        }      } else {         System.out.println("NO MATCH");      }   }}</code></pre><p>输出结果</p><pre><code>Found value: This order was placed for QT3000! OK?Found value: This order was placed for QTFound value: 3000Found value: ! OK?</code></pre><pre><code>package com.java.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexMatches2 {    public static void main(String[] args) {        // 去除单词与 , 和 . 之间的空格        String content = "Hello , World .";        String pattern = "(\\w)(\\s+)([.,])";        // $0 匹配 `(\w)(\s+)([.,])` 全部，结果为 `o空格,` 和 `d空格.`        // $1 匹配 `(\w)` 结果为 `o` 和 `d`        // $2 匹配 `(\s+)` 结果为 `空格` 和 `空格`        // $3 匹配 `([.,])` 结果为 `,` 和 `.`        System.out.println(content.replaceAll(pattern, "$1$3"));         //输出为 Hello, World.    }}</code></pre><h2 id="2-6-1-仅创建分组不反向引用"><a href="#2-6-1-仅创建分组不反向引用" class="headerlink" title="2.6.1 仅创建分组不反向引用"></a>2.6.1 仅创建分组不反向引用</h2><p>当我们在小括号 () 内的模式开头加入 ?:，那么表示这个模式仅分组，但不创建反向引用。</p><p>实例</p><pre><code>package com.java.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest {    public static void main(String[] args) {        String content = "Hello.java";        //分组        Pattern pattern = Pattern.compile("(class|java)");        Matcher matcher = pattern.matcher(content);        while (matcher.find()){            System.out.println(matcher.group());            System.out.println(matcher.group(1));        }    }}</code></pre><p>此时可以反向引用，输出为</p><pre><code>javajava</code></pre><p>但若将pattern变成(?:class|java),输出结果为</p><pre><code>javaException in thread "main" java.lang.IndexOutOfBoundsException: No group 1    at java.util.regex.Matcher.group(Matcher.java:538)    at com.java.regex.RegexTest.main(RegexTest.java:15)</code></pre><h2 id="2-6-2反向引用的副本"><a href="#2-6-2反向引用的副本" class="headerlink" title="2.6.2反向引用的副本"></a>2.6.2反向引用的副本</h2><p>可以在小括号中使用 ?<name> 将小括号中匹配的内容保存为一个名字为 name 的副本或者说别名。</name></p><p>实例</p><pre><code>package com.java.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest {    public static void main(String[] args) {        String content = "Hello.java";        //分组        Pattern pattern = Pattern.compile("(?&lt;extension&gt;class|java)");        Matcher matcher = pattern.matcher(content);        while (matcher.find()){            System.out.println(matcher.group());            System.out.println(matcher.group(1));            System.out.println(matcher.group("extension"));        }    }}</code></pre><p>输出为</p><pre><code>javajavajava</code></pre><h2 id="2-7反斜杠"><a href="#2-7反斜杠" class="headerlink" title="2.7反斜杠"></a>2.7反斜杠</h2><p>由于Java中反斜杠”\“字符的转义作用(ps：md中也是一样)，在普通字符串中使用”\\“表示一个反斜杠，故在正则表达式中\\.表示\.,\\\\表示\\用于在正则表达式来匹配\ 。</p><h2 id="2-8否定"><a href="#2-8否定" class="headerlink" title="2.8否定"></a>2.8否定</h2><p>a(?|b)表示a后不跟b</p><h1 id="3-模式和匹配"><a href="#3-模式和匹配" class="headerlink" title="3.模式和匹配"></a>3.模式和匹配</h1><p>Java 中使用正则表达式需要用到两个类，分别为 java.util.regex.Pattern 和 java.util.regex.Matcher。</p><p>第一步，通过正则表达式创建模式对象 Pattern。</p><p>第二步，通过模式对象 Pattern，根据指定字符串创建匹配对象 Matcher。</p><p>第三步，通过匹配对象 Matcher，根据正则表达式操作字符串。</p><p>实例</p><pre><code>package com.java.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest {    //使用单词边界，以确保字母 "c" "a" "t" 并非仅是一个较长的词的子串    private static final String REGEX = "\\bcat\\b";    private static final String INPUT =            "cat cat cat cattie cat";    public static void main( String args[] ){        Pattern p = Pattern.compile(REGEX);        Matcher m = p.matcher(INPUT); // 获取 matcher 对象        int count = 0;        while(m.find()) {            count++;            System.out.println("Match number "+count);            System.out.println("start(): "+m.start());            System.out.println("end(): "+m.end());        }        // 创建第二个模式，将空格替换为 ^        Pattern replace = Pattern.compile("\\s+");        Matcher matcher2 = replace.matcher(INPUT);        System.out.println(matcher2.replaceAll("^"));    }}</code></pre><p>输出为</p><pre><code>Match number 1start(): 0end(): 3Match number 2start(): 4end(): 7Match number 3start(): 8end(): 11Match number 4start(): 19end(): 22cat^cat^cat^cattie^cat</code></pre><h1 id="4-使用案例"><a href="#4-使用案例" class="headerlink" title="4.使用案例"></a>4.使用案例</h1><h2 id="4-1-数字范围"><a href="#4-1-数字范围" class="headerlink" title="4.1 数字范围"></a>4.1 数字范围</h2><p>匹配1997-2019</p><p>错误示范[1997-2019]</p><p>应该写成<br>^199[7-9]$|^20[0-1][0-6]$|^201[7-9]$</p><h2 id="4-2-贪婪与非贪婪匹配"><a href="#4-2-贪婪与非贪婪匹配" class="headerlink" title="4.2 贪婪与非贪婪匹配"></a>4.2 贪婪与非贪婪匹配</h2><pre><code>package com.java.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest {    public static void main(String[] args) {        String str = "&lt;div&gt;文章标题&lt;/div&gt;&lt;div&gt;发布时间&lt;/div&gt;";        // 贪婪模式        Pattern pattern = Pattern.compile("&lt;div&gt;(?&lt;title&gt;.+)&lt;/div&gt;");        Matcher matcher = pattern.matcher(str);        while (matcher.find()) {            System.out.println(matcher.group("title"));        }        System.out.println("--------------");        // 非贪婪模式        pattern = Pattern.compile("&lt;div&gt;(?&lt;title&gt;.+?)&lt;/div&gt;");        matcher = pattern.matcher(str);        while (matcher.find()) {            System.out.println(matcher.group("title"));        }    }}</code></pre><p>输出</p><pre><code>文章标题&lt;/div&gt;&lt;div&gt;发布时间--------------文章标题发布时间</code></pre><p>还有独占模式+,即尽可能多地匹配，但是不回溯,这篇文章给出一个使用独占模式解决bug的例子<a href="https://www.cnblogs.com/Renyi-Fan/p/9694695.html" target="_blank" rel="noopener">链接</a>.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/12/hello-world/"/>
      <url>/2019/12/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>contact</title>
      <link href="/contact/index.html"/>
      <url>/contact/index.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>friends</title>
      <link href="/friends/index.html"/>
      <url>/friends/index.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
    </entry>
    
    
  
</search>
